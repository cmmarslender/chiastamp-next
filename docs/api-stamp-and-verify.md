# ChiaStamp Stamping and Verification API Guide

This document describes the ChiaStamp API contract for:

- stamping a file hash (`/stamp`)
- refreshing proof state (`/proof`)
- verifying on-chain commitment data via RPC (`get_coin_records_by_hint`, `get_block_record_by_height`)

It also documents privacy boundaries, especially what must stay client-side.

## 1) System model

ChiaStamp's stamping API is intentionally minimal: it only requires a leaf hash to commit data into the Merkle batch and anchor that commitment on-chain.

Everything else can remain client-side, regardless of client type (browser app, mobile app, desktop app, backend service, or CLI).

A typical client-agnostic flow is:

1. The client computes a salted file hash locally.
2. Only that hash is sent to the stamping backend.
3. The backend returns a Merkle proof object.
4. The client stores that proof JSON (including local salt).
5. Later, verification is performed locally plus chain RPC checks.

No raw file bytes need to be uploaded in this model.

## 2) Privacy boundary: what to send and what not to send

### Send to stamping backend

- `hash` only (hex SHA-256 digest, produced locally)

### Do not send to stamping backend

- raw file contents
- `salt`

### Why `salt` stays client-side

The backend only needs a Merkle leaf hash. It does not need the salt value to stamp or return proofs. Keeping salt client-side reduces information exposed to service operators and network observers, and avoids sharing extra metadata that is unnecessary for stamping.

You should still store salt in your local proof file so you can recompute the salted hash later during verification.

## 3) Stamping flow (`POST /stamp`)

Set a stamping API base URL once for your target network/environment.

Examples:

- `https://api.chiastamp.com` (mainnet)
- `https://testnet11-api.chiastamp.com` (testnet11)

### Request

`POST {STAMP_API_BASE}/stamp`

```json
{
  "hash": "9c5df5890f4e6f3a2c5d7f2b0f6800b8ce2d0f5f8c27b85f5be80dd2aa00c5ad"
}
```

### Response (`ProofResponse`)

```json
{
  "confirmed": false,
  "root_hash": "42bc2f5db2fdbf5ea5fe3449e9707a65e0eb2a97f0f5799bf6e64d9f6e8f6a9d",
  "leaf_hash": "9c5df5890f4e6f3a2c5d7f2b0f6800b8ce2d0f5f8c27b85f5be80dd2aa00c5ad",
  "proof": [
    {
      "hash": "7d6a91fd9e0d630b553f2df75d4c5b87a994f8ff8f9f2c03b18008a15c8458b3",
      "position": "left"
    }
  ]
}
```

When saving this proof file locally, the client augments it with:

- `salt` (hex string, generated by the client)

## 4) Proof file format to persist

The proof object shape is:

```ts
interface ProofStep {
  hash: string;
  position: "left" | "right";
}

interface ProofResponse {
  confirmed: boolean;
  header_hash?: string;
  coin_id?: string;
  root_hash: string;
  leaf_hash: string;
  proof: ProofStep[];
  salt?: string;
}
```

### Required for any verification

- `leaf_hash`
- `root_hash`
- `proof`
- `confirmed`

### Required for full on-chain verification

- `header_hash`
- `coin_id`

### Required for salted hash verification

- `salt`

### Minimal persisted proof example

```json
{
  "confirmed": true,
  "header_hash": "6d3f48a345e4a3f6f1389d2c2be8d6eb6af2fa81e8f1c91d2f47f53eb0f51ab2",
  "coin_id": "b19073d6fef8f89f2e5e7f0f95f3110b1ce917ab663bcd85f85ed5a7f102f9cb",
  "root_hash": "42bc2f5db2fdbf5ea5fe3449e9707a65e0eb2a97f0f5799bf6e64d9f6e8f6a9d",
  "leaf_hash": "9c5df5890f4e6f3a2c5d7f2b0f6800b8ce2d0f5f8c27b85f5be80dd2aa00c5ad",
  "proof": [
    {
      "hash": "7d6a91fd9e0d630b553f2df75d4c5b87a994f8ff8f9f2c03b18008a15c8458b3",
      "position": "left"
    }
  ],
  "salt": "3f0fe3a178f3d97a552dc3207d907c2f2389426abf8f4e490146778f87e53d70"
}
```

## 5) Refreshing proof state (`POST /proof`)

This endpoint checks whether a proof has progressed from partial to confirmed, and returns a newer proof object when one is available.

### Request

`POST {STAMP_API_BASE}/proof`

```json
{
  "hash": "9c5df5890f4e6f3a2c5d7f2b0f6800b8ce2d0f5f8c27b85f5be80dd2aa00c5ad"
}
```

If your local proof contains `salt`, recompute the salted file hash first and send that hash.

### Response

Same `ProofResponse` schema as `/stamp`.

If changed and now confirmed, persist updated proof fields while preserving your original local `salt`.

### Partial proof vs full proof (important)

- A **partial proof** has the Merkle data (`leaf_hash`, `root_hash`, `proof`) but is not yet fully anchored for independent chain verification.
- A **full proof** is a proof that has been included in a blockchain block, represented by `confirmed: true` plus `coin_id` and `header_hash`.
- After receiving a partial proof, call `POST /proof` every few minutes (not continuously) to check for an updated full proof, and replace your stored copy when it arrives.

## 6) Verification steps and responsibility split

### A) Client-side checks (local, no backend trust needed)

1. Recompute salted hash from original file: `SHA256(file_bytes || salt)`.
2. Compare computed hash to `leaf_hash`.
3. Recompute Merkle path from `leaf_hash` and each proof step:
   - if step is `"left"`, hash `sibling || current`
   - if step is `"right"`, hash `current || sibling`
4. Compare computed root to `root_hash`.

### B) On-chain checks (chain RPC)

Before chain RPC calls, ensure these fields exist:

- `confirmed === true`
- `coin_id`
- `header_hash`

Then:

1. Query coin records by hint using `root_hash`.
2. Find a record where `coin.parent_coin_info` equals `coin_id` (normalize optional `0x` prefixes).
3. Query block record by that coin's `confirmed_block_index`.
4. Confirm returned `block_record.header_hash` equals proof `header_hash` (also normalize optional `0x`).

## 7) Coinset vs self-hosted full node

Coinset is a public/open RPC provider exposing the same methods used here. It is optional.

All verification RPC calls in this model can be directed to:

- Coinset public endpoint, or
- your own fully synced Chia full node RPC endpoint

The method names and JSON payloads stay the same; only the base URL/transport target changes.

Once you have a full proof, verification can be performed independently using only:

- your original file
- your proof JSON (including salt)
- access to chain RPC (for example, your own fully synced full node)

At that point, ChiaStamp does not need to be involved in the verification process.

### RPC base URL

Set one RPC base URL for your chosen provider or your own full node.

Examples:

- `https://api.coinset.org` (public mainnet provider)
- `https://testnet11.api.coinset.org` (public testnet11 provider)
- `https://<your-full-node-host>:8555` (self-hosted full node RPC)

### RPC #1: get coin records by hint

`POST {RPC_BASE}/get_coin_records_by_hint`

```json
{
  "hint": "42bc2f5db2fdbf5ea5fe3449e9707a65e0eb2a97f0f5799bf6e64d9f6e8f6a9d",
  "include_spent_coins": true
}
```

Example success shape:

```json
{
  "success": true,
  "coin_records": [
    {
      "coin": {
        "parent_coin_info": "0xb19073d6fef8f89f2e5e7f0f95f3110b1ce917ab663bcd85f85ed5a7f102f9cb",
        "puzzle_hash": "0x...",
        "amount": 1
      },
      "coinbase": false,
      "confirmed_block_index": 1234567,
      "spent": false,
      "spent_block_index": 0,
      "timestamp": 1736022222
    }
  ]
}
```

### RPC #2: get block record by height

`POST {RPC_BASE}/get_block_record_by_height`

```json
{
  "height": 1234567
}
```

Example success shape:

```json
{
  "success": true,
  "block_record": {
    "header_hash": "0x6d3f48a345e4a3f6f1389d2c2be8d6eb6af2fa81e8f1c91d2f47f53eb0f51ab2",
    "height": 1234567
  }
}
```

## 8) End-to-end operational checklist

1. Hash file locally with a fresh random 32-byte salt.
2. Send only `hash` to `POST /stamp`.
3. Save proof JSON locally and include `salt`.
4. Later, load original file + proof JSON.
5. Run local checks (file hash and Merkle path).
6. If proof is not confirmed yet, call `POST /proof` with same hash and refresh local proof.
7. Run chain RPC checks using either Coinset or your own full node.
8. Accept proof as fully verified only after coin linkage and header-hash checks pass.

## 9) Common pitfalls

- Sending `salt` to backend: unnecessary and weakens privacy boundary.
- Losing `salt`: salted files cannot be re-verified against `leaf_hash`.
- Treating partial proof as final: require `confirmed`, `coin_id`, and `header_hash` for full chain verification.
- Skipping `0x` normalization: compare hash-like fields after trimming optional prefixes.
